

# [Live]C++ Programming

## 2023.03.27~03.31 

1. 오버로딩 전반
    - 7p
    - 함수명은 같고 parameter list 부분이 달라야 함
    - parameter 개수, parameter의 type, 배치 순서
    - const 포인터와 일반 포인터는 다른 type
    - 하나의 함수명으로 다양한 type 처리에 유용
    - 자동형변환에 의한 호출(char -> int, float -> double)
2. Default Parameter
    - 10p
    - default Parameter를 지정하면 그 이후 parameter는 모두 default Parameter
3. reference 문법
    - 15p
    - 다른 변수에 대한 별명(alias)
    - 실제 변수에 반영됨, (like, call by pointer)
    - 함수 / 메서드(멤버 함수)의 parameter나 return type으로도 사용 가능
    - 참조 변수는 선언과 동시에 참고하고자 하는 변수로 초기화 해야함
    - 포인터와의 차이점
        - 참조 변수의 주소를 출력하면 참조 대상의 주소가 나옴
        - 초기화 이후에는 참조 대상을 변경할 수 없음
    - 참조 포인터 변수 : 포인터 변수의 참조형
```cpp
data-type * 포이터 변수 명;
data-type * &참조 변수 명 = 포인터 변수 명;
```
    - 참조 배열 : 배열의 참조형
```cpp
data-type 배열 명[n];
data-type (&참조 배열 명)[n] = 배열 명; // 거의 사용 X, 크기 지정해야 함
```
4. 동적 Memory 할당 기법
    - 27p
    - new, delete, new[], delete[]
    - 28p 문제
5. 네임 스페이스
    - 22p
    - 여러 가지 식별자들을 이름이 있는 범위로 그룹화하는 기법
    - 식별자들의 종류
        - 변수, 함수, 구조체, 클래스, 공용체, typedef 등
    - **using** : namespace안의 식별자를 namespace명 없이 사용하기 위한 명령어
    - 중첩 사용 : 가까운 함수 호출
6. 인라인함수
    - 29p
    - 함수 몸체를 호출한 곳에 삽입
    - 일반 함수보다 약간 빠르지만, 메모리 사용
    - 매크로 함수 대신에 사용
        - 매크로 = 전처리기, 인라인 함수 = 컴파일러
7. this Pointer
    - 39p
    - 클래스의 모든 멤버 함수는 묵시적 전달인자로 this 포인터를 가짐
    - 멤버 함수를 호출한 객체의 주소가 this 포인터에 저장
    - 컴파일 타임에 추가
    - 숨겨져 있음, 꼭 해야하는 경우 : 같은 변수 명
8. 생성자
    - 41p
    - 생성자 : 클래스 객체를 선언하여 메모리가 할당될 때 자동으로 호출되는 클래스 멤버 함수
    - 소멸자 : 전달인자 없음, 오버로딩 불가
9. 멤버 초기화 List
    - 49p
    - 생성자의 정의부 {}가 시작되기 전에 ':' 기호를 사용하여 멤버 변수를 초기화
    - 생성자에서만 사용 가능
    - 배열은 멤버초기화 리스트에서 초기화 불가능
    - 포인터 변수의 경우 가능
    - 멤버초기화 리스트의 대상
        - 일반 멤버 변수, const 멤버 변수(필수), 참조 멤버 변수(필수), 포함된 객체의 생성자 호출, 상속받은 객체의 생성자 호출
10. 복사 생성자
    - 63p
    - 복사 생성자 : 동일한 속성을 갖는 객체를 생성하기 위한 생성자
    - 기존에 존재하는 객체와 동일한 속성을 갖는 객체를 만들고자 할 때 자동으로 호출 됨
        - 이미 생성된 객체로 새로운 객체를 생성할 때
        - call by value 기법으로 객체의 값을 보낼 때
        - 함수의 return 값으로 객체의 값을 리턴할 때
    - 얕은 복사 : 주소 전달
    - 깊은 복사 : 주소의 값을 복사하여 전달
    - explicit : 묵시적 호출 예방 기호
11. Static Member, Const Member
    - 72p
    - 정적 멤버 변수
        - 같은 클래스의 객체들 사이에 공유되는 멤버 변수
        - 클래스에 속한 변수
            - 클래스 영역 구분자를 통하여 객체가 없어도 접근이 가능함
        - 클래스 내에서 선언 후 밖에서 반드시 정의
    - 54p
    - const 멤버 변수
        - 클래스의 멤버 함수를 const로 선언하면 함수 안에서 클래스의 어떠한 멤버 값도 변경이 불가능
        - const 멤버 함수에서는 const 멤버 함수만 호출 가능
        - const 객체는 const 멤버 함수만을 호출할 수 있음
        - const 키워드의 여러 가지 사용 형식
            - 리턴 값에 대한 const : 리턴 값에 대한 수정 불가
            - 함수의 전달인자에 대한 const : 함수 내에서 전달 인자에 대한 수정 불가
            - 클래스 멤버 함수의 const : 멤버 함수 내에서 클래스 멤버에 대한 수정 불가
12. 연산자 오버로딩 전반
    - 79p
    - 연산자 오버로딩 함수 : "operator연산자기호"의 형식으로 정의되는 함수
    - 클래스 타임만 연산자 오버로딩이 지원됨
    - 리턴 타입은 연산자 오버로딩 함수의 종류에 따라 다름
13. 대입 연산자
    - 디폴트 대입 연산자 오버로딩 : 클래스에서 = 연산자를 정의하지 않는다면 디폴트 대입 연산자 실행
        - 단 깊은 복사를 해야하는 객체의 경우 반드 시 사용자가 직접 깊은 복사 대입연산자 함수 작성
14. freind 기법
    - 85p
    - 외부에서 클래스의 private, protected 멤버에 직접 접근하도록 허용하는 방법
    - friend 함수
        - 클래스 내부에 friend 키워드를 사용하여 일반 함수를 선언
        - 클래스 외부의 일반 함수에서 클래스의 모든 멤버에 직접 접근하여 사용 가능
            - 일반 함수가 클래스의 멤버 함수처럼 동작함
    - freind 클래스
        - 클래스 내부에 friend 키워드를 사용하여 클래스 타입 선언
        - friend로 등록된 class의 모든 멤버 함수는 해당 클래스의 모든 멤버에 직접 접근하여 사용 가능
15. 함수 오버라이딩
    - 107p
    - 기본 클래스의 멤버 함수를 상속받은 파생 클레스에서 멤버 함수를 새롭게 구현하거나 기본 클래스의 멤버 함수의 기능을 확장하는 것
    - 오버 라이딩 특징
        - 기본 클래스의 멤버 함수와 파생 클래스의 멤버 함수 프로토 타입 일치
        - 기본 클래스의 기존에 있던 멤버 함수 기능은 은폐됨
16. 바인딩
    - 114p
    - 함수의 이름과 함수의 구현부를 결합
17. Virtual 키워드
    - 115p
    - virtual 을 붙여야 자식에서 재정의 가능(overriding)
    - 가상 소멸자(virtual destructor) : 메모리 해제가 안될 수 있으므로, 소멸자 + virtual
18. 순수가상함수
    - 122p
19. 추상 Class
    - 122p